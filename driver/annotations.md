# Adding UAST Annotations

# Intro

Once you have written the [AST parser](driver/sdk.md) the
next step is to write the annotation code. This is the Go language code that will
establish the rules to transform the original AST into the UAST and the
implementation uses two objects, the ObjectToNoder and the AnnotationRules on two
separate files.  Most of the files related to the Go part of the driver are
auto-generated by the [`bblfsh-sdk init`
tool](driver/sdk.md), but in
order to translate the native AST to the UAST you need to complete two skeleton
files that are referenced in the (auto-generated) driver/main.go file.

## File: parser.go

### ToNoder interface & implementation

ToNoder is a interface that annotators would need to fill in the
`driver/normalizer/parser.go` file, but a default ObjectToNoder implementation is
provided in the SDK for trees represented as nested JSON objects. It serves to
establish the role of some internal keys in the native AST into specific key roles
in the UAST. This is needed so the rule applying process knows what parts of the
native AST use to do the translation. The skeleton of this struct will be
automatically generated by the `bblfsh-sdk init` command. 

The meaning of the fields in the ObjectToNoder struct are:

- InternalTypeKey (string): this is the name of the key that the native AST uses
  to differentiate the type of the AST nodes. This internal key will then be
  checkable in the AnnotationRules with the `HasInternalType` predicate. This
  field is mandatory.

- LineKey (string): this is the key used in the native AST to indicate 
  the line number where the code mapped to the AST node starts. 

- OffsetKey (string): this is the key used in the native AST to indicate
  the absolute offset, from the file start position, where the code mapped to 
  the AST node starts.

- ColumnKey (string): this is the key used in the native AST to indicate 
  the column number where the code mapped to the AST node starts.

- TokenKeys (map[string]bool): this map establishes what properties (as in JSON
  keys) in the native AST nodes can be mapped to Tokens in the UAST. If the
  InternalTypeKey is the "type" of a node, the Token could be tough of as the
  "value" representation; this could be a specific value for string/numeric
  literals or the symbol name for others.  E.g.: if a native AST represents a
  numeric literal as: `{"ast_type": NumLiteral, "value": 2}` then you should have
  to add `"value": true` to the TokenKeys map.  Some native ASTs will use several
  different fields as tokens depending on the node type; in that case, all should
  be added to this map to ensure a correct UAST generation.

- SyntheticTokens (map[string][string]): sometimes native ASTs just use an
  InternalTypeKey for some node but we need to add a Token to the UAST node to
  improve the representation. In this case we can add both the InternalKey and
  what token it should generate. E.g.: an InternalTypeKey called "NullLiteral" in
  Java should be mapped using this map to "null" adding ```"NullLiteral":
  "null"``` to this map.

- TopLevelIsRootNode (bool): this boolean switch specifies if the parsing must be
  start with the first node found at the top level (`true`) or one of their children
  (`false`). This is needed because some native ASTs start with "AST" or some
  other nonsignificant keys at the top level.

- PromotedPropertyLists (map[string]map[string]bool): By default the UAST
  generation will set as children of a node any object that hangs from any of the
  original native AST node properties. In this process, object key serving as
  the parent is lost and its name is added as the "internalRole" key of the children.
  This is usually fine since the InternalTypeKey of the parent AST node will
  usually provide enough context and the node won't any other children. This map
  allows you to change this default behavior for specific nodes so the properties
  are "promoted" to a new node (with an InternalTypeKey named "Parent.KeyName")
  and the objects in its list will be shown in the UAST as children. E.g.: if you
  have a native AST where an "If" node has the JSON keys "body", "else" and
  "condition" each with its own list of children, you could add an entry to
  PromotedPropertyLists like:

  ```
  "If": {"body": true, "orelse": true, "condition": true},
  ```

  In this case, the new nodes will have the InternalTypeKey "If.body", "If.orelse"
  and "If.condition" and with these names you should be able to write specific 
  matching rules in the annotation.go file.

### UASTParserBuilder function

This automatically generated function will return a driver.UASTParser object that
will be constructed using your provided ToNoder implementation. This is the function
referred in the main.go file and you usually will not need to change it.

### Examples

Check the already implemented [Java
ObjectToNoder](https://github.com/bblfsh/java-driver/blob/master/driver/normalizer/parser.go)
or [Python
one](https://github.com/bblfsh/python-driver/blob/master/driver/normalizer/parser.go)
for real world examples of the ObjectToNoder struct filled.

## File: annotation.go

### AnnotationRules 

This variable will hold a Rule object and is the result of the applying of the
different rules using the functions defined in the file ``sdk/uast/ann/ann.go``
file. This is done by calling the `On` rule constructor and chaining calls to the
different selectors, rule constructors (a rule can hold other rules itself) and
predicates to build your AST to UAST transformator.

To see how rules are built it's important to understand that a rule is composed
of:

- One or more *predicates* that will select what nodes will match the rule.
- One of more *actions* that will apply to the matching nodes.
- Zero or more *selectors* that will optionally select more nodes starting
  from the current ones and apply the rule/s in its argument list.
- Zero or more additional *rules* contained inside to the *selectors*.

The rule constructor is the function `On(predicates...) *Rule`. As you can see
in the signature, it takes one of more predicates and returns a rule pointer. This 
allows for chaining of different methods taking a rule pointer. A general form
for a rule definition could this be like:

```go
// Simple example:
var r  := On(somePredicate).SomeAction(actionParams)

// A more elaborate example:
var r2 := On(otherPredicate).SomeSelector(
    On(thirdPredicate).SomeAction(actionParams), // embedded rule
    On(fouthPredicate).SomeSelector( // embedded rule with its own childs
        On(fithPredicate).SomeAction(actionParams),
    )).SomeAction(actionPArams)
```

#### Predicates

Predicates are any function that follow the signature: 

```go
func(n *uast.Node) bool
```

Where uast.Node are the Nodes that will be iterated during the annotation
process. You could define your own predicate functions but the ann.go file
has already defined the ones that you'll probably need most of the time:

- `Any()`: always returns true. It's usually used to match the first node in 
  the native AST and add rules from there.

- `Not/And/Or(predicate)`: will apply the expected boolean operations to 
  the predicate(s) used as argument.

- `HasInternalType(type string)`: checks if the InternalType of the node matches
  the string provided. What key is the InternalType of a native AST node is 
  defined in the `parser.ObjectToNoder.InternalTypeKey` field.

- `HasToken(name string)`: checks if the node has a token matching the given
  string. What key of the node is a Token is defined in the 
  `parser.ObjectToNoder.TokenKeys` map.

- `HasChild(predicate)`: will check if any of the first level children of
  the current node matches the given predicate.

- `HasProperty(key, value string)`: checks if the AST node has some specific key
  and the key as the given value.

- `HasInternalRole(key string)`: this is actually a very handy shortcut to 
  `HasProperty(uast.InternalRoleKey, value)` that will check if the node has
  an InternalRole matching the specified key. InternalRoles are
  added to children of any object keys holding them.

#### Actions

- `Roles(roles... uast.Role)`: Will add the given UAST role to the currently
  selected node(s).

- `Error(err Error)`: Will produce an error and stop processing the AST.

#### Selectors

- `Self(rules ...*Rule)`: Selects the current node.

- `Children(rules ...*Rule)`: Select the children of the current node. Please note
   that only the first level children are selected, second level ("grandchildren")
   and others below are not selected (use Descendants for those).

- `Descendants(rules ...*Rule)`: Selects all (recursive) descendants of the
  selected node.

- `DescendantsOrSelf(rules ...*Rule)`: Selects the current node and all
  (recursive) descendants.

### Examples:

Check the already implemented [Java
annotator](https://github.com/bblfsh/java-driver/blob/master/driver/normalizer/annotation.go)
or the [Python
annotator](https://github.com/bblfsh/python-driver/blob/master/driver/normalizer/annotation.go)
for real world examples of this API in action.

### When in doubt...

[//]: # FIXME: (uncomment this paragraph when the table is available)
[//]: # If you find a node in the native AST that you're unsure how to map into the UAST
[//]: # the first step is to check how other languages map the same or similar nodes.  For
[//]: # this you can check this [Annotation table](FIXME link when available) that show how
[//]: # different languages have mapped their internal roles to the UAST ones.

You can also ask any doubt on the project's public [Babelfish Slack
channel](https://sourced-community.slack.com/join/shared_invite/MTkwNTM0ODEyODIzLTE0OTYxMzc5NTMtODRhMDYyNzAyYQ)
which is very friendly to newcomers to the project.

Finally, if you really think that there isn't a correspondence in the UAST roles
for the native role that you want to map, you can fork the [Babelfish SDK project
on Github](https://github.com/bblfsh/sdk), add the new role to the file
`uast/uast.go` and make a PR. Don't expect the role to be added inmediatedly;
we're somewhat picky about freely adding roles to the UAST and depending on the
stage of the project we strive for adding the more generalizable roles first
before adding exotic or very language-specific ones. If your role falls into the
second category the PR will be tagged as "need-research" which means that it will
be re-evaluated when a similar role is needed for other languages (and thus me can
see how to generalize it to cover more ground) or there is a new version of the
UAST.
